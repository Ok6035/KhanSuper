<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Color Predictor — Local</title>
<style>
  :root{
    --bg:#0f1724; --panel:#0b1220; --muted:#94a3b8; --accent:#60a5fa;
    --card:#0b1220; --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue";
    background: linear-gradient(180deg,#071025 0%, #071827 100%); color:#e6eef6;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }
  .wrap{max-width:980px;margin:28px auto;padding:18px;}
  header{display:flex;align-items:center;gap:12px;margin-bottom:18px}
  .logo{width:62px;height:62px;border-radius:12px;background:linear-gradient(135deg,#1e3a8a,#065f46);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px}
  h1{margin:0;font-size:20px}
  p.lead{margin:4px 0 0;color:var(--muted);font-size:13px}
  .grid{display:grid;grid-template-columns: 1fr 360px; gap:18px;}
  .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,0.03)}
  .big-input{display:flex;gap:12px;align-items:center}
  input[type="text"]{font-size:32px;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;width:220px}
  button{background:var(--accent);border:none;padding:10px 14px;border-radius:10px;color:#04263b;font-weight:700;cursor:pointer}
  .result{margin-top:16px;padding:14px;border-radius:10px;background:linear-gradient(90deg,rgba(255,255,255,0.02),transparent);display:flex;align-items:center;gap:12px}
  .result .pill{font-weight:800;padding:8px 12px;border-radius:999px;font-size:20px}
  .stats{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .stat{background:var(--glass);padding:8px 10px;border-radius:10px;font-size:13px;color:var(--muted)}
  canvas{width:100%;height:160px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent)}
  .small{font-size:13px;color:var(--muted);margin-top:8px}
  label.switch{display:flex;align-items:center;gap:8px;cursor:pointer}
  .footer-note{font-size:12px;color:#9fb4d6;margin-top:10px}
  .controls{display:flex;flex-direction:column;gap:8px}
  .compact{display:flex;gap:8px;align-items:center}
  .import-area{width:100%;height:90px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px dashed rgba(255,255,255,0.03);color:var(--muted)}
  .muted{color:var(--muted)}
  @media (max-width:900px){.grid{grid-template-columns:1fr;}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo">CP</div>
    <div>
      <h1>Color Predictor — Local</h1>
      <p class="lead">Enter last 3 digits of a period. Predicts <strong>Big (5–9)</strong> or <strong>Small (0–4)</strong> with trend analysis and client-side learning.</p>
    </div>
  </header>

  <div class="grid">
    <main class="card">
      <section>
        <div class="big-input">
          <input id="periodInput" placeholder="Enter last 3 digits (e.g. 123)" maxlength="3" inputmode="numeric" pattern="[0-9]*" />
          <button id="predictBtn">Predict Next</button>
          <button id="addBtn" title="Add this result to local history">Add Result</button>
        </div>
        <div class="result" id="resultPanel" style="display:none;">
          <div id="outcomePill" class="pill">BIG</div>
          <div>
            <div id="confidenceText" style="font-weight:700">Confidence: 75%</div>
            <div class="small muted" id="suggestionText">Suggested color: Green</div>
          </div>
        </div>
        <div class="stats" id="quickStats">
          <!-- populated by JS -->
        </div>

        <h3 style="margin-top:16px">Trend (last 100)</h3>
        <canvas id="trendCanvas"></canvas>

        <h3 style="margin-top:12px">Pattern heat / recent list</h3>
        <div id="recentList" class="small muted"></div>
      </section>

      <section style="margin-top:14px">
        <h3>Manual Import (CSV)</h3>
        <div class="small muted">Paste a CSV of historic results: one column with 3-digit period and the observed next single-digit result (0–9). Example line: <code>001,7</code></div>
        <textarea id="importArea" class="import-area" placeholder="001,7\n002,3\n..."></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="importBtn">Import CSV</button>
          <button id="clearHistoryBtn" style="background:#ef4444;color:white">Clear Local History</button>
        </div>
      </section>

      <section style="margin-top:12px">
        <h3>Auto-update (optional)</h3>
        <div class="small muted">If you have your own CORS-enabled JSON endpoint that returns history in the same CSV style, you may enable automated fetches. <strong>Do not</strong> enable this unless you have explicit permission to access the remote data.</div>
        <div class="compact" style="margin-top:8px">
          <input id="remoteUrl" placeholder="https://your-server.example/api/history.json" style="flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)" />
          <button id="enableFetchBtn">Enable Fetch</button>
        </div>
        <div class="small muted" id="fetchStatus" style="margin-top:8px"></div>
      </section>

      <div class="footer-note">Local learner stores history only in your browser (localStorage). No data leaves your device unless you enable remote fetch.</div>
    </main>

    <aside class="card">
      <div style="display:flex;flex-direction:column;gap:12px">
        <div>
          <h4 style="margin:0">AI Learner</h4>
          <div class="small muted">Learns mapping from last-3 → next digit. Uses frequency + Laplace smoothing and recency weighting.</div>
        </div>

        <div>
          <label class="compact"><input type="checkbox" id="useRecency" checked/> Use recency decay (favor recent data)</label>
          <div class="small muted">Recency reduces older samples' weight over time to adapt to changing trends.</div>
        </div>

        <div>
          <label class="compact"><input type="checkbox" id="showProbabilities" checked/> Show probabilities</label>
        </div>

        <div>
          <h4 style="margin:0">Model internals</h4>
          <div class="small muted">Smoothing α: <span id="sAlpha">1.0</span></div>
        </div>

        <div>
          <h4 style="margin:0">History size</h4>
          <div class="small muted" id="historySize">0 records</div>
          <div style="margin-top:6px">
            <button id="exportBtn">Export local CSV</button>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:8px 0">
        <div>
          <strong>Usage tips</strong>
          <ul class="small muted" style="padding-left:16px;margin:6px 0 0">
            <li>Start by importing known history for better accuracy.</li>
            <li>Use manual add to tune model quickly.</li>
            <li>Enable remote fetch only for endpoints you control.</li>
          </ul>
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
/*
  Color Predictor — Local
  - Local history in localStorage key "cp_history" as array of {period3, nextDigit, ts}
  - Model: for each period3 -> counts of digits 0..9 with time-weighting
  - Predict big/small by summing probabilities for digits 0-4 (small) and 5-9 (big)
  - Provide color suggestion:
      - green for prefer big, red for prefer small
  - Remote fetch is opt-in; disabled by default
*/

// ---------- Utilities ----------
function el(id){return document.getElementById(id)}
function safeParseInt(s, fallback=NaN){const n=parseInt(s,10);return Number.isFinite(n)?n:fallback}
function nowTs(){return Date.now()}

// ---------- Storage ----------
const STORAGE_KEY = 'cp_history_v1';
function loadHistory(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return [];
    return arr;
  }catch(e){console.warn("loadHistory err",e); return [];}
}
function saveHistory(history){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
  }catch(e){console.warn("saveHistory err",e);}
}

// ---------- Model ----------
/*
  Build model: map period3 -> counts {digit: weightedCount}
  We can use exponential recency decay: weight = exp(-(now - ts)/decayMs)
*/
function buildModel(history, opts){
  const now = nowTs();
  const decayMs = opts.useRecency ? (1000 * 60 * 60 * 24 * 30) : Infinity; // default 30d half effect
  const alpha = opts.smoothing; // Laplace smoothing amount

  const model = Object.create(null);

  for(const rec of history){
    if(!rec || typeof rec.period3 !== 'string') continue;
    if(typeof rec.nextDigit !== 'number') continue;
    const p = rec.period3;
    const d = rec.nextDigit;
    const age = Math.max(0, now - (rec.ts || now));
    const weight = opts.useRecency ? Math.exp(-age / decayMs) : 1;
    if(!model[p]) model[p] = {counts: Array(10).fill(0), total:0};
    model[p].counts[d] += weight;
    model[p].total += weight;
  }

  // after collecting, compute probabilities with Laplace smoothing
  const modelOut = {};
  for(const p in model){
    const entry = model[p];
    const counts = entry.counts;
    const total = entry.total;
    // probabilities
    const probs = counts.map(c => (c + alpha) / (total + alpha * 10));
    modelOut[p] = {probs, total};
  }
  return modelOut;
}

// Predict given period3
function predictFor(period3, model, opts){
  // fallback: if no exact pattern, use aggregated global distribution
  const globalProbs = Array(10).fill(1/10);
  let probs = globalProbs;
  if(model[period3]) probs = model[period3].probs;
  else {
    // try pattern fallback: last 2 digits, last 1 digit, or average
    const p2 = period3.slice(-2);
    const p1 = period3.slice(-1);
    if(model[p2]) probs = model[p2].probs;
    else if(model[p1]) probs = model[p1].probs;
    else {
      // average of all entries
      const all = Array(10).fill(0);
      let n=0;
      for(const k in model){
        for(let i=0;i<10;i++) all[i]+=model[k].probs[i];
        n++;
      }
      if(n>0) probs = all.map(x => x/n);
    }
  }
  // big = sum 5..9; small = sum 0..4
  const smallProb = probs.slice(0,5).reduce((a,b)=>a+b,0);
  const bigProb = probs.slice(5).reduce((a,b)=>a+b,0);
  const suggested = bigProb > smallProb ? 'BIG' : 'SMALL';
  const confidence = Math.round(Math.max(bigProb, smallProb)*100);
  // color suggestion
  const color = suggested === 'BIG' ? 'green' : 'red';
  return {probs, smallProb, bigProb, suggested, confidence, color};
}

// ---------- UI and interactions ----------
const historyUI = {list: loadHistory()};
const options = {
  useRecency: true,
  smoothing: 1.0
};

function refreshUI(){
  el('historySize').textContent = historyUI.list.length + ' records';
  const model = buildModel(historyUI.list, {useRecency: options.useRecency, smoothing: options.smoothing});
  drawTrend(historyUI.list);
  updateQuickStats(model);
  // update recent list
  const recent = historyUI.list.slice(-20).map(r => `${r.period3}→${r.nextDigit}`).reverse().join(' • ');
  el('recentList').textContent = recent || 'No recent records';
  saveHistory(historyUI.list);
}

// quick stats (last 100)
function updateQuickStats(model){
  const q = el('quickStats');
  q.innerHTML = '';
  const last = historyUI.list.slice(-100);
  if(last.length===0){
    q.innerHTML = '<div class="stat">No history</div>';
    return;
  }
  const bigCount = last.filter(r => r.nextDigit >=5).length;
  const smallCount = last.length - bigCount;
  q.appendChild(statNode('Last ' + last.length, `${bigCount} big / ${smallCount} small`));
  // most common next digit
  const digitCounts = Array(10).fill(0);
  for(const r of last) digitCounts[r.nextDigit]++;
  const topDigit = digitCounts.map((c,i)=>[c,i]).sort((a,b)=>b[0]-a[0])[0];
  q.appendChild(statNode('Top digit', topDigit ? topDigit[1] + ' ('+topDigit[0]+')' : '-'));
  q.appendChild(statNode('Unique patterns', Object.keys(model).length));
}

function statNode(title, value){
  const d = document.createElement('div'); d.className='stat';
  d.innerHTML = `<div style="font-weight:700">${title}</div><div style="margin-top:6px">${value}</div>`;
  return d;
}

// Trend chart (simple)
function drawTrend(history){
  const canvas = el('trendCanvas');
  canvas.width = canvas.clientWidth * devicePixelRatio;
  canvas.height = canvas.clientHeight * devicePixelRatio;
  const ctx = canvas.getContext('2d');
  ctx.scale(devicePixelRatio, devicePixelRatio);
  const w = canvas.clientWidth, h = canvas.clientHeight;

  // draw background grid
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,0,w,h);

  const lastN = history.slice(-60);
  if(lastN.length===0){
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    ctx.font='12px system-ui';
    ctx.fillText('No data', 12, 20);
    return;
  }
  // map digits to numeric 0-9 scaled to height
  const pad = 24;
  const stepX = (w - pad*2) / Math.max(1, lastN.length-1);
  ctx.lineWidth = 2;
  // draw small as lower line, big as higher? We'll plot nextDigit itself
  ctx.beginPath();
  for(let i=0;i<lastN.length;i++){
    const x = pad + i * stepX;
    const y = pad + (h - pad*2) * (1 - lastN[i].nextDigit / 9);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = 'rgba(96,165,250,0.9)';
  ctx.stroke();

  // overlay big/small markers
  for(let i=0;i<lastN.length;i++){
    const x = pad + i * stepX;
    const d = lastN[i].nextDigit;
    ctx.beginPath();
    ctx.arc(x, pad + (h - pad*2) * (1 - d/9), 3, 0, Math.PI*2);
    ctx.fillStyle = d>=5 ? 'rgba(34,197,94,0.95)' : 'rgba(239,68,68,0.95)';
    ctx.fill();
  }
}

// predict button
el('predictBtn').addEventListener('click', ()=>{
  const raw = (el('periodInput').value||'').trim();
  if(!/^\d{1,3}$/.test(raw)){ alert('Enter 1-3 digits (0-999)'); return; }
  const p = raw.padStart(3,'0');
  const model = buildModel(historyUI.list, {useRecency: options.useRecency, smoothing: options.smoothing});
  const pred = predictFor(p, model, {smoothing: options.smoothing});
  showPrediction(pred, p);
});

// add result button (user indicates the observed next digit)
el('addBtn').addEventListener('click', async ()=>{
  const raw = (el('periodInput').value||'').trim();
  if(!/^\d{1,3}$/.test(raw)){ alert('Enter 1-3 digits (0-999)'); return; }
  const p = raw.padStart(3,'0');
  let next = prompt('Enter observed next single-digit result (0–9):');
  if(next === null) return;
  next = next.trim();
  if(!/^[0-9]$/.test(next)){ alert('Invalid digit'); return; }
  const rec = {period3: p, nextDigit: parseInt(next,10), ts: nowTs()};
  historyUI.list.push(rec);
  refreshUI();
  alert('Added to local history.');
});

// import CSV
el('importBtn').addEventListener('click', ()=>{
  const txt = el('importArea').value.trim();
  if(!txt){ alert('Paste CSV lines first'); return; }
  const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  let added=0;
  for(const ln of lines){
    // accept "001,7" or "001;7" or "001 7"
    const parts = ln.split(/[,; \t]+/);
    if(parts.length < 2) continue;
    const p = parts[0].padStart(3,'0').slice(-3);
    const d = parseInt(parts[1],10);
    if(!/^\d{3}$/.test(p) || !Number.isFinite(d) || d<0 || d>9) continue;
    historyUI.list.push({period3:p, nextDigit:d, ts: nowTs()});
    added++;
  }
  refreshUI();
  alert('Imported ' + added + ' rows.');
});

// clear history
el('clearHistoryBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all local history?')) return;
  historyUI.list = [];
  saveHistory(historyUI.list);
  refreshUI();
});

// export CSV
el('exportBtn').addEventListener('click', ()=>{
  const csv = historyUI.list.map(r => `${r.period3},${r.nextDigit},${new Date(r.ts).toISOString()}`).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'cp_history.csv'; document.body.appendChild(a); a.click();
  a.remove(); URL.revokeObjectURL(url);
});

// showPrediction
function showPrediction(pred, p){
  el('resultPanel').style.display = 'flex';
  const pill = el('outcomePill');
  if(pred.suggested === 'BIG'){
    pill.textContent = 'BIG';
    pill.style.background = 'linear-gradient(90deg, rgba(34,197,94,0.12), rgba(34,197,94,0.06))';
    pill.style.color = '#bff5d3';
  } else {
    pill.textContent = 'SMALL';
    pill.style.background = 'linear-gradient(90deg, rgba(239,68,68,0.12), rgba(239,68,68,0.06))';
    pill.style.color = '#ffd6d6';
  }
  el('confidenceText').textContent = 'Confidence: ' + pred.confidence + '%';
  el('suggestionText').textContent = `Suggested color: ${pred.suggested === 'BIG' ? 'Green' : 'Red'} — Prob(BIG)=${Math.round(pred.bigProb*100)}% Prob(SMALL)=${Math.round(pred.smallProb*100)}%`;
  // show probability bar below pill optionally
  if(el('showProbabilities').checked){
    // small rendering: create simple bar under result
  }
}

// options toggles
el('useRecency').addEventListener('change', (e)=>{ options.useRecency = e.target.checked; refreshUI(); });

// enable fetch
let fetchInterval = null;
el('enableFetchBtn').addEventListener('click', ()=>{
  const url = el('remoteUrl').value.trim();
  if(!url){ alert('Enter remote JSON/CSV endpoint URL first'); return; }
  if(fetchInterval){
    clearInterval(fetchInterval); fetchInterval = null; el('fetchStatus').textContent = 'Auto fetch disabled.';
    el('enableFetchBtn').textContent = 'Enable Fetch';
    return;
  }
  // confirm
  if(!confirm('Enabling remote fetch will attempt to retrieve data periodically from the URL you provided. Only enable if you own the endpoint or have permission.')) return;
  const fetchAndMerge = async ()=>{
    try{
      el('fetchStatus').textContent = 'Fetching...';
      const resp = await fetch(url, {cache:'no-cache'});
      if(!resp.ok){ el('fetchStatus').textContent = 'Fetch failed: ' + resp.status; return; }
      // try JSON first
      let text = await resp.text();
      // detect if it's CSV-style
      if(text.trim().startsWith('[') || text.trim().startsWith('{')){
        // assume JSON array of {period3: "001", nextDigit: 7}
        const js = JSON.parse(text);
        let added = 0;
        if(Array.isArray(js)){
          for(const r of js){
            if(r && typeof r.period3 === 'string' && typeof r.nextDigit === 'number'){
              historyUI.list.push({period3:r.period3.padStart(3,'0').slice(-3), nextDigit:r.nextDigit, ts: r.ts || nowTs()});
              added++;
            }
          }
        }
        el('fetchStatus').textContent = `Fetched JSON — added ${added} rows`;
      } else {
        // parse as CSV-like
        const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        let added=0;
        for(const ln of lines){
          const parts = ln.split(/[,; \t]+/);
          if(parts.length < 2) continue;
          const p = parts[0].padStart(3,'0').slice(-3);
          const d = parseInt(parts[1],10);
          if(!/^\d{3}$/.test(p) || !Number.isFinite(d) || d<0 || d>9) continue;
          historyUI.list.push({period3:p, nextDigit:d, ts: nowTs()});
          added++;
        }
        el('fetchStatus').textContent = `Fetched CSV — added ${added} rows`;
      }
      refreshUI();
    }catch(err){
      console.warn('fetch err', err);
      el('fetchStatus').textContent = 'Fetch error: ' + (err.message || err);
    }
  };

  // first immediate fetch
  fetchAndMerge();
  // periodic every 60s for example (safe low frequency)
  fetchInterval = setInterval(fetchAndMerge, 60*1000);
  el('enableFetchBtn').textContent = 'Disable Fetch';
  el('fetchStatus').textContent = 'Auto fetch enabled (every 60s).';
});

// initial load
refreshUI();

// small safety: try-catch around main loop to auto-heal if exception thrown
window.addEventListener('error', function(ev){
  console.error('Global error caught', ev);
  // attempt to recover by refreshing UI after small delay
  setTimeout(()=>{ try{ refreshUI(); }catch(e){console.warn(e);} }, 400);
});
</script>
</body>
</html>
